// See https://aka.ms/new-console-template for more information
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace lyricism
{
    public class Program
    {
        public enum PostDataType
        {
            Json,
            Form
        }
        internal static bool NoIndent = !Environment.UserInteractive || Console.WindowWidth == 0;

        internal static string CacheDir = System.IO.Path.Join(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".cache", "lyricism");
        internal static string LyricsCacheDir = System.IO.Path.Join(CacheDir, "lyrics");
        internal static string TokensPath = System.IO.Path.Join(CacheDir, "tokens.json");
        internal static string NoLyricsLogPath = System.IO.Path.Join(CacheDir, "nolyrics.log");

        internal const string ansiEmphasis = "\x1B[1;31m";
        internal const string ansiDim= "\x1B[35m";
        internal const string ansiReset = "\x1B[0m";

        public static bool TinyMode
        {
            get
            {
                return Console.WindowWidth <= 40;
            }
        }

        /// <param name="artistName"></param>
        /// <param name="trackName"></param>
        /// <param name="site"></param>
        /// <param name="noCache"></param>
        /// <param name="clearCache"></param>
        /// <param name="addSpotifyAccount"></param>
        /// <param name="watchSpotify"></param>
        public static void Main(string artistName, string trackName, string site, bool noCache, bool clearCache, bool listSites,
                bool verbose,
                bool addSpotifyAccount, bool watchSpotify,
                bool translate, string translateLang = "en-us"
                )
        {
            if (addSpotifyAccount)
            {
                Spotify.AddSpotifyAccount();
                return;
            }

            if (clearCache)
            {
                if (!System.IO.Directory.Exists(Program.LyricsCacheDir))
                    Console.WriteLine("No lyrics cache found.");
                else
                    System.IO.Directory.Delete(Program.LyricsCacheDir, true);

                Console.WriteLine("Cache cleared.");
                return;
            }

            if (watchSpotify)
            {
                Watcher.Watch(site, noCache, verbose, translate, translateLang);
                return;
            }

            if (listSites)
            {
                var extractors = GetExtractors(null, null, site, noCache);
                var siteList = extractors.Select(x => x.SourceName).Join("\n");
                Console.WriteLine(siteList);
                return;
            }

            if (string.IsNullOrWhiteSpace(artistName) && string.IsNullOrWhiteSpace(trackName) && !System.IO.File.Exists(TokensPath))
            {
                Console.WriteLine("Provide --artist-name and --track-name or authenticate with Spotify.");
                Console.WriteLine();
                System.CommandLine.DragonFruit.CommandLine.ExecuteAssembly(typeof(AutoGeneratedProgram).Assembly, new string[] { "--help" }, "");
                return;
            }

            IEnumerable<string> podcastDescriptionArray = null;

            if (string.IsNullOrWhiteSpace(artistName) && string.IsNullOrWhiteSpace(trackName))
            {
                var playing = Spotify.GetCurrentlyPlayingDeets();
                if (playing == null || !string.IsNullOrWhiteSpace( playing.Errors))
                {
                    Console.WriteLine(playing?.Errors ?? "Erroneous Spotify state.");
                    return;
                }
                artistName = playing.ArtistName;
                trackName = playing.TrackName;
                podcastDescriptionArray = playing.PodcastDescriptionArray;
            }

            // TODO restructure this to handle podcast description prettier, with better formatting
            foreach (var blurb in podcastDescriptionArray ?? GetLyricReport(artistName, trackName, site, noCache, verbose, translate, translateLang))
            {
                var blurbx = FormatLyricReport(blurb);
                // hacky but efficient
                if (!blurbx.StartsWith("\r") && !blurbx.EndsWith("\r"))
                    blurbx = (blurbx + "\n").ReplaceLineEndings();
                Console.Write(blurbx);
            }
        }

        internal static IEnumerable<LyricExtractor> GetExtractors(string artistName, string trackName, string site, bool noCache)
        {
            var extractors = AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.GetTypes())
                  .Where(x => typeof(LyricExtractor).IsAssignableFrom(x) && !x.IsInterface && !x.IsAbstract)
                  .Select(x => x.GetConstructors().First().Invoke(new object[] { artistName, trackName }))
                  .Cast<LyricExtractor>()
                  .Where(x => x != null)
                  .Where(x => 1 == 2
                              || (!site.IsNullOrWhiteSpace() && x.SourceName.SearchTermMatch(site))
                              || (site.IsNullOrWhiteSpace() && x.Active)
                              )
                  .Where(x => !noCache || !x.IsCache)
                  .OrderBy(x => x.Order)
                  .ToList();

            return extractors;
        }

        public static IEnumerable<string> GetLyricReport(string artistName, string trackName, string site, bool noCache, bool verbose, bool translate, string translateLang)
        {
            var extractors = GetExtractors(artistName, trackName, site, noCache);

            LyricExtractor ex = null;
            var totalEx = extractors.Count();
            var i = 0;
            foreach (var extra in extractors)
            {
                i+=1;
                // TODO make this a percent
                // yield return "\rChecking sources: " + i.ToString();
                yield return "\rChecking sources: " + i.ToString() + "/" + totalEx.ToString() +", " + ((double)i/totalEx).ToString("P1");
                if (!string.IsNullOrWhiteSpace(extra.Lyrics))
                {
                    ex = extra;
                    break;
                }
            }

            yield return "\r"; // effectively queue up the progress line to be overwritten

            var debugLogs = extractors.SelectMany(ex => ex.DebugLog.Select(x => "[debug][" + ex.SourceName + "] " + x)).Join("\n");

            if (verbose)
                yield return debugLogs;

            if (ex == null)
            {
                //if (extractors.Any(ex => !string.IsNullOrWhiteSpace(ex.TrackName)))
                //    yield return "Found a page but could not find lyrics for: " + artistName + " - " + trackName + ".";
                //else
                yield return "Could not find lyrics for: " + artistName + " - " + trackName + ".";

                System.IO.File.AppendAllText(NoLyricsLogPath, artistName + " - " + trackName + "\n");
                yield break;
            }

            var outputLyrics = ex.Lyrics;


            if (verbose)
                yield return LineyBoi();

            var trackDeets = ex.ArtistName + " - "+ ex.TrackName;
            if (trackDeets.Length > Console.WindowWidth)
                trackDeets = ex.ArtistName + "\n" + ex.TrackName;
            yield return trackDeets;

            yield return string.Empty;
            if (!ex.IsCache)
                yield return LineyBoi(ex.SourceName);
            else
                yield return LineyBoi(ex.SubSourceName + " (cached)");

            yield return string.Empty;
            // skip lyrics and print a summary of lyrics for verbose here instead?

            var indent = string.Empty;
            if (ex.IsInstrumental())
                indent = " ".Repeat((Console.WindowWidth - ex.Lyrics.Length) / 2);

            if (translate) // && string.IsNullOrWhiteSpace(ex.Translation)) // would have to determine language too
                yield return ex.GetTranslation(translateLang);
            else
                yield return indent + ex.Lyrics;

            yield return "\n" + LineyBoi() + "\r";

            ex.Cache();
        }

        internal static string FormatLyricReport(string value)
        {
            if (Program.NoIndent)
                return value;

            var lines = new List<string>();
            foreach (var line in value.Split("\n"))
            {
                var startString = line.TrimEnd();
                // handle carriage returns
                if (startString.Contains("\r"))
                {
                    startString = startString.Substring(line.LastIndexOf("\r"));
                }
                // probably won't encounter an initial indent much but hey
                var initialIndent = startString.TakeWhile(c => c == ' ').Count();
                var newIndent = (Console.WindowWidth >= 100 ? 4 : 2);
                while (startString.Length > Console.WindowWidth)
                {
                    var wrapAt = Console.WindowWidth - 1;
                    var lastSpaceAt = startString.Substring(0, wrapAt).LastIndexOf(" ");
                    if (wrapAt - lastSpaceAt < 15 && initialIndent + newIndent + lastSpaceAt < Console.WindowWidth)
                        wrapAt = lastSpaceAt;

                    var frontPart = startString.Substring(0, wrapAt).TrimEnd();
                    startString = " ".Repeat(initialIndent) + " ".Repeat(newIndent) + startString.Substring(wrapAt).Trim();
                    lines.Add(frontPart);
                }

                lines.Add(startString.TrimEnd());
            }

            for (int chunkSize = (int)Math.Floor(lines.Count() / 2.0); chunkSize > 0; chunkSize--) 
            {
                for (int firstChunkPos = 0; firstChunkPos < lines.Count() - chunkSize; firstChunkPos++) 
                {
                    var secondChunkPos = firstChunkPos + chunkSize;
                    var firstChunk = lines.Skip(firstChunkPos).Take(chunkSize).ToList();
                    var secondChunk = lines.Skip(secondChunkPos).Take(chunkSize).ToList();

                    // TODO only use ansi codes in supported shells

                    var firstChunkCompare = firstChunk.Select(x => x.TrimStart(ansiEmphasis).TrimEnd(ansiReset).Trim()).ToList();
                    var secondChunkCompare = secondChunk.Select(x => x.TrimStart(ansiEmphasis).TrimEnd(ansiReset).Trim()).ToList();

                    if (Enumerable.SequenceEqual(firstChunkCompare, secondChunkCompare))
                    {
                       lines.RemoveRange(secondChunkPos, chunkSize);
                       var firstChunkStart = lines[firstChunkPos];
                       if (!firstChunkStart.StartsWith(ansiEmphasis))
                           lines[firstChunkPos] = ansiEmphasis + firstChunkStart;
                       var firstChunkEndPos = firstChunkPos + chunkSize - 1;
                       var firstChunkEnd = lines[firstChunkEndPos];
                       if (!firstChunkEnd.EndsWith(ansiReset))
                           lines[firstChunkEndPos] = firstChunkEnd + ansiReset;

                       // if a chunk is removed, stay put for the next loop
                       firstChunkPos -= 1;
                    }

                }
            }

            var labelRegex = @"^[\[\(\}](instrumental|outro)?( | / )?(pre-|post-)?(chorus|verse|bridge|hook|intro|outro|break|breakdown|build|section|sung|spoken|refrain|drop|gibberish|solo \w+?|\w+? solo)( \d| x\d)?(: .+?)?[\]\)\}]$";

            // TODO these labels wrap for small screens
            // ex: --artist-name 'bridge sinner' --track-name 'devil like you'
            var labelMatches = lines
                .Distinct()
                .Select(line => line.RegexMatch(labelRegex))
                .Distinct()
                .ToArray();

                if (labelMatches.Any())
                    lines = lines.Select(line => labelMatches.Contains(line)
                            ? ansiDim + line + ansiReset
                            : line).ToList();
            
            var output = lines.Join("\n");
            return output;
        }
        private const int LineLength = 30;
        private static string LineyBoi(string label = null)
        {
            if (TinyMode)
            {
                var border = 2;
                var output = " ".Repeat(border / 2) + LineyBoi(Console.WindowWidth - border, label);
                return output;
            }
            else
                return LineyBoi(LineLength, label);
        }
        private static string LineyBoi(int len, string label = null)
        {
            label ??= string.Empty;
            var sideLen = (len - label.Length) / 2;
            var output = "-".Repeat(sideLen) + label.Replace(" ", "-") + "-".Repeat(sideLen);

            // mainly for odd label lengths
            var diff = len - output.Length;
            output += "-".Repeat(diff);

            return output;
        }
    }
}
