// See https://aka.ms/new-console-template for more information
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace lyricism
{
    public class Program
    {
        public enum PostDataType
        {
            Json,
            Form
        }
        internal static bool NoIndent = !Environment.UserInteractive || Console.WindowWidth == 0;

        internal static string CacheDir = System.IO.Path.Join(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), ".cache", "lyricism");
        internal static string LyricsCacheDir = System.IO.Path.Join(CacheDir, "lyrics");
        internal static string TokensPath = System.IO.Path.Join(CacheDir, "tokens.json");
        internal static string NoLyricsLogPath = System.IO.Path.Join(CacheDir, "nolyrics.log");

        internal const string ansiEmphasis = "\x1B[1;31m";
        internal const string ansiReset = "\x1B[0m";

        /// <param name="artistName"></param>
        /// <param name="trackName"></param>
        /// <param name="site"></param>
        /// <param name="noCache"></param>
        /// <param name="clearCache"></param>
        /// <param name="spotifyAuth"></param>
        /// <param name="watchSpotify"></param>
        public static void Main(string artistName, string trackName, string site, bool noCache, bool clearCache, bool listSites,
                bool verbose,
                bool spotifyAuth, bool watchSpotify)
        {
            //if (Debugger.IsAttached)
            //    watchSpotify = true;

            if (spotifyAuth)
            {
                Spotify.SpotifyAuth();
                return;
            }

            if (clearCache)
            {
                if (!System.IO.Directory.Exists(Program.LyricsCacheDir))
                    Console.WriteLine("No lyrics cache found.");
                else
                    System.IO.Directory.Delete(Program.LyricsCacheDir, true);

                Console.WriteLine("Cache cleared.");
                return;
            }

            if (watchSpotify)
            {
                Watcher.Watch(site, noCache, verbose);
                return;
            }

            if (listSites)
            {
                var extractors = GetExtractors(null, null, site, noCache);
                var siteList = extractors.Select(x => x.SourceName).Join("\n");
                Console.WriteLine(siteList);
                return;
            }

            if (string.IsNullOrWhiteSpace(artistName) && string.IsNullOrWhiteSpace(trackName) && !System.IO.File.Exists(TokensPath))
            {
                Console.WriteLine("Provide --artist-name and --track-name or authenticate with Spotify.");
                Console.WriteLine();
                System.CommandLine.DragonFruit.CommandLine.ExecuteAssembly(typeof(AutoGeneratedProgram).Assembly, new string[] { "--help" }, "");
                return;
            }

            IEnumerable<string> podcastDescriptionArray = null;

            if (string.IsNullOrWhiteSpace(artistName) && string.IsNullOrWhiteSpace(trackName))
            {
                var playing = Spotify.GetCurrentlyPlayingDeets();
                if (playing == null || !string.IsNullOrWhiteSpace( playing.Errors))
                {
                    Console.WriteLine(playing?.Errors ?? "Erroneous Spotify state.");
                    return;
                }
                artistName = playing.ArtistName;
                trackName = playing.TrackName;
                podcastDescriptionArray = playing.PodcastDescriptionArray;
            }

            // TODO restructure this to handle podcast description prettier, with better formatting
            foreach (var blurb in podcastDescriptionArray ?? GetLyricReport(artistName, trackName, site, noCache, verbose))
            {
                var blurbx = FormatLyricReport(blurb);
                // hacky but efficient
                if (!blurbx.StartsWith("\r"))
                    blurbx += "\n"; // TODO how does this look on windows?
                Console.Write(blurbx.ReplaceLineEndings());
            }
        }

        internal static IEnumerable<LyricExtractor> GetExtractors(string artistName, string trackName, string site, bool noCache)
        {
            var extractors = AppDomain.CurrentDomain.GetAssemblies().SelectMany(x => x.GetTypes())
                  .Where(x => typeof(LyricExtractor).IsAssignableFrom(x) && !x.IsInterface && !x.IsAbstract)
                  .Select(x => x.GetConstructors().First().Invoke(new object[] { artistName, trackName }))
                  .Cast<LyricExtractor>()
                  .Where(x => x != null)
                  .Where(x => 1 == 2
                              || (!string.IsNullOrWhiteSpace(site) && x.SourceName.Contains(site, StringComparison.InvariantCultureIgnoreCase))
                              || (string.IsNullOrWhiteSpace(site) && x.Active)
                              )
                  .Where(x => !noCache || !x.IsCache)
                  .OrderBy(x => x.Order)
                  .ToList();

            return extractors;
        }

        internal static IEnumerable<string> GetLyricReport(string artistName, string trackName, string site, bool noCache, bool verbose)
        {
            var extractors = GetExtractors(artistName, trackName, site, noCache);

            LyricExtractor ex = null;
            var totalEx = extractors.Count();
            var i = 0;
            foreach (var extra in extractors)
            {
                i+=1;
                // TODO make this a percent
                // yield return "\rChecking sources: " + i.ToString();
                yield return "\rChecking sources: " + i.ToString() + "/" + totalEx.ToString() +", " + ((double)i/totalEx).ToString("P1");
                if (!string.IsNullOrWhiteSpace(extra.Lyrics))
                {
                    ex = extra;
                    break;
                }
            }

            yield return "\r"; // effectively queue up the progress line to be overwritten

            var debugLogs = extractors.SelectMany(ex => ex.DebugLog.Select(x => "[debug][" + ex.SourceName + "] " + x)).Join("\n");

            if (verbose)
                yield return debugLogs;

            if (ex == null)
            {
                //if (extractors.Any(ex => !string.IsNullOrWhiteSpace(ex.TrackName)))
                //    yield return "Found a page but could not find lyrics for: " + artistName + " - " + trackName + ".";
                //else
                yield return "Could not find lyrics for: " + artistName + " - " + trackName + ".";

                System.IO.File.AppendAllText(NoLyricsLogPath, artistName + " - " + trackName + "\n");
                yield break;
            }

            if (verbose)
                yield return "-".Repeat(30);

            yield return ex.ArtistName + " - " + ex.TrackName;
            if (!ex.IsCache)
                yield return "    " + ex.SourceName;
            else
                yield return "    " + ex.SubSourceName + " (cached)";

            // skip lyrics and print a summary of lyrics for verbose here instead?

            yield return "-".Repeat(30);
            yield return ex.Lyrics;

            ex.Cache();
        }

        internal static string FormatLyricReport(string value)
        {
            if (Program.NoIndent)
                return value;

            var lines = new List<string>();
            foreach (var line in value.Split("\n"))
            {
                var startString = line.TrimEnd();
                // handle carriage returns
                if (startString.Contains("\r"))
                {
                    startString = startString.Substring(line.LastIndexOf("\r"));
                }
                // probably won't encounter an initial indent much but hey
                var initialIndent = startString.TakeWhile(c => c == ' ').Count();
                var newIndent = (Console.WindowWidth >= 100 ? 4 : 2);
                while (startString.Length > Console.WindowWidth)
                {
                    var wrapAt = Console.WindowWidth - 1;
                    var lastSpaceAt = startString.Substring(0, wrapAt).LastIndexOf(" ");
                    if (wrapAt - lastSpaceAt < 15 && initialIndent + newIndent + lastSpaceAt < Console.WindowWidth)
                        wrapAt = lastSpaceAt;

                    var frontPart = startString.Substring(0, wrapAt).TrimEnd();
                    startString = " ".Repeat(initialIndent) + " ".Repeat(newIndent) + startString.Substring(wrapAt).Trim();
                    lines.Add(frontPart);
                }

                lines.Add(startString.TrimEnd());
            }

            for (int chunkSize = (int)Math.Floor(lines.Count() / 2.0); chunkSize > 0; chunkSize--) 
            {
                for (int firstChunkPos = 0; firstChunkPos < lines.Count() - chunkSize; firstChunkPos++) 
                {
                    var secondChunkPos = firstChunkPos + chunkSize;
                    var firstChunk = lines.Skip(firstChunkPos).Take(chunkSize).ToList();
                    var secondChunk = lines.Skip(secondChunkPos).Take(chunkSize).ToList();

                    // TODO only use ansi codes in supported shells

                    var firstChunkCompare = firstChunk.Select(x => x.TrimStart(ansiEmphasis).TrimEnd(ansiReset).Trim()).ToList();
                    var secondChunkCompare = secondChunk.Select(x => x.TrimStart(ansiEmphasis).TrimEnd(ansiReset).Trim()).ToList();

                    if (Enumerable.SequenceEqual(firstChunkCompare, secondChunkCompare))
                    {
                       lines.RemoveRange(secondChunkPos, chunkSize);
                       var firstChunkStart = lines[firstChunkPos];
                       if (!firstChunkStart.StartsWith(ansiEmphasis))
                           lines[firstChunkPos] = ansiEmphasis + firstChunkStart;
                       var firstChunkEndPos = firstChunkPos + chunkSize - 1;
                       var firstChunkEnd = lines[firstChunkEndPos];
                       if (!firstChunkEnd.EndsWith(ansiReset))
                           lines[firstChunkEndPos] = firstChunkEnd + ansiReset;


                       // if a chunk is removed, stay put for the next loop
                       firstChunkPos -= 1;
                    }

                }
            }

            var output = lines.Join("\n");
            return output;
        }
    }
}
